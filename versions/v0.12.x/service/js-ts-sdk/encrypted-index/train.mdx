---
title: "Train"
mode: "wide"
---

Trains the encrypted index to optimize it for efficient similarity search queries. Training is essential for IVF-based indexes to achieve optimal query performance and accuracy.

```typescript
async train(
    batchSize: number = 2048,
    maxIters: number = 100,
    tolerance: number = 1e-6
): Promise<object>
```

### Parameters

| Parameter | Type | Default | Description |
|-----------|------|---------|-------------|
| `batchSize` | `number` | `2048` | _(Optional)_ Size of each batch processed during training. Larger values may improve training quality but use more memory |
| `maxIters` | `number` | `100` | _(Optional)_ Maximum number of iterations for the training algorithm. More iterations may improve accuracy but take longer |
| `tolerance` | `number` | `1e-6` | _(Optional)_ Convergence tolerance for training. Smaller values result in more precise training but may take longer |

<Note>Training is a compute-intensive operation that may take several seconds to minutes depending on the index size and configuration.</Note>

### Returns

`Promise<object>`: A Promise that resolves to a response object containing the operation status and training completion message.

### Exceptions

<AccordionGroup>
    <Accordion title="Error">
        - Throws if the API request fails due to network connectivity issues.
        - Throws if authentication fails (invalid API key).
        - Throws if the encryption key is invalid for the specified index.
        - Throws if there are insufficient resources to complete training.
    </Accordion>
    <Accordion title="Training Errors">
        - Throws if the index has no vectors to train on.
        - Throws if the index configuration is incompatible with training.
        - Throws if training parameters are out of valid ranges.
        - Throws if training fails to converge within the specified parameters.
    </Accordion>
</AccordionGroup>

### Example Usage

#### Basic Index Training

```typescript
import { Client } from 'cyborgdb';

const client = new Client('http://localhost:8000', 'your-api-key');

// Load an existing index
const indexKey = new Uint8Array(Buffer.from('your-stored-hex-key', 'hex'));
const index = await client.loadIndex('my-vector-index', indexKey);

// Add vectors to the index first
await index.upsert([
    { id: 'doc1', vector: [0.1, 0.2, 0.3, 0.4], metadata: { title: 'Document 1' } },
    { id: 'doc2', vector: [0.4, 0.5, 0.6, 0.7], metadata: { title: 'Document 2' } },
    { id: 'doc3', vector: [0.7, 0.8, 0.9, 1.0], metadata: { title: 'Document 3' } }
]);

// Train the index with default parameters
try {
    console.log('Starting index training...');
    const startTime = Date.now();
    
    const result = await index.train();
    
    const duration = Date.now() - startTime;
    console.log(`Training completed in ${duration}ms`);
    console.log('Training result:', result);
    // Typical output: { status: 'success', message: "Index 'my-vector-index' trained successfully" }
    
    // Verify training completed
    const isTrained = await index.isTrained();
    console.log('Index is now trained:', isTrained);
    
    // Index is now optimized for queries
    const queryResults = await index.query([0.1, 0.2, 0.3, 0.4], undefined, 5);
    console.log('Query after training:', queryResults);
    
} catch (error: any) {
    console.error('Training failed:', error.message);
}
```

#### Custom Training Parameters

```typescript
// High-quality training with custom parameters
async function trainHighQuality(index: EncryptedIndex): Promise<object> {
    try {
        console.log('Starting high-quality training...');
        
        const result = await index.train(
            4096,    // batchSize: larger batches for better quality
            200,     // maxIters: more iterations for convergence
            1e-8     // tolerance: stricter convergence criteria
        );
        
        console.log('High-quality training completed:', result);
        return result;
        
    } catch (error: any) {
        console.error('High-quality training failed:', error.message);
        throw error;
    }
}

// Fast training with relaxed parameters
async function trainFast(index: EncryptedIndex): Promise<object> {
    try {
        console.log('Starting fast training...');
        
        const result = await index.train(
            1024,    // batchSize: smaller batches for speed
            50,      // maxIters: fewer iterations for speed
            1e-4     // tolerance: relaxed convergence for speed
        );
        
        console.log('Fast training completed:', result);
        return result;
        
    } catch (error: any) {
        console.error('Fast training failed:', error.message);
        throw error;
    }
}

// Usage based on requirements
const requiresHighAccuracy = true; // Based on your use case

if (requiresHighAccuracy) {
    await trainHighQuality(index);
} else {
    await trainFast(index);
}
```

#### Training with Progress Monitoring

```typescript
async function trainWithMonitoring(
    index: EncryptedIndex,
    customParams?: {
        batchSize?: number;
        maxIters?: number;
        tolerance?: number;
    }
): Promise<{ success: boolean; duration: number; result: any }> {
    
    const startTime = Date.now();
    
    try {
        // Check if already trained
        const alreadyTrained = await index.isTrained();
        if (alreadyTrained) {
            console.log('‚ö† Index is already trained');
            return {
                success: true,
                duration: 0,
                result: { message: 'Index was already trained' }
            };
        }
        
        console.log('üöÄ Starting training process...');
        console.log('Training parameters:', {
            batchSize: customParams?.batchSize || 2048,
            maxIters: customParams?.maxIters || 100,
            tolerance: customParams?.tolerance || 1e-6
        });
        
        const result = await index.train(
            customParams?.batchSize,
            customParams?.maxIters,
            customParams?.tolerance
        );
        
        const duration = Date.now() - startTime;
        
        // Verify training completion
        const isNowTrained = await index.isTrained();
        
        if (isNowTrained) {
            console.log(`‚úÖ Training completed successfully in ${duration}ms`);
            console.log('Training result:', result);
        } else {
            console.warn('‚ö† Training completed but index may not be fully trained');
        }
        
        return {
            success: true,
            duration,
            result
        };
        
    } catch (error: any) {
        const duration = Date.now() - startTime;
        console.error(`‚ùå Training failed after ${duration}ms:`, error.message);
        
        return {
            success: false,
            duration,
            result: { error: error.message }
        };
    }
}

// Usage
const trainingResult = await trainWithMonitoring(index, {
    batchSize: 3072,
    maxIters: 150,
    tolerance: 1e-7
});

if (trainingResult.success) {
    console.log('Training metrics:', {
        duration: trainingResult.duration,
        success: trainingResult.success
    });
}
```

#### Conditional Training Workflow

```typescript
async function ensureIndexTrained(
    index: EncryptedIndex,
    forceRetrain: boolean = false
): Promise<{ wasTrained: boolean; justTrained: boolean; result?: any }> {
    
    try {
        // Check current training status
        const currentlyTrained = await index.isTrained();
        
        if (currentlyTrained && !forceRetrain) {
            console.log('‚úì Index is already trained and ready for queries');
            return { wasTrained: true, justTrained: false };
        }
        
        if (currentlyTrained && forceRetrain) {
            console.log('üîÑ Forcing retraining of already trained index');
        }
        
        if (!currentlyTrained) {
            console.log('‚ö† Index requires training before optimal querying');
        }
        
        // Perform training
        console.log('üéØ Training index...');
        const result = await index.train();
        
        // Verify training completed
        const isNowTrained = await index.isTrained();
        
        return {
            wasTrained: currentlyTrained,
            justTrained: isNowTrained,
            result
        };
        
    } catch (error: any) {
        console.error('Training workflow failed:', error.message);
        throw error;
    }
}

// Usage examples
try {
    // Ensure index is trained (train only if needed)
    const workflow1 = await ensureIndexTrained(index);
    
    // Force retraining regardless of current status
    const workflow2 = await ensureIndexTrained(index, true);
    
    console.log('Training workflow completed:', workflow1);
    
} catch (error) {
    console.error('Training workflow error:', error);
}
```

#### Training for Different Index Types

```typescript
async function optimizedTrainingByType(index: EncryptedIndex): Promise<object> {
    try {
        // Get index configuration to optimize training
        const config = await index.getIndexConfig();
        const indexType = config.indexType;
        
        console.log(`Optimizing training for index type: ${indexType}`);
        
        let trainingParams = {
            batchSize: 2048,
            maxIters: 100,
            tolerance: 1e-6
        };
        
        // Optimize parameters based on index type
        switch (indexType) {
            case 'ivf':
                // Standard IVF - balanced parameters
                trainingParams = {
                    batchSize: 2048,
                    maxIters: 100,
                    tolerance: 1e-6
                };
                break;
                
            case 'ivf_flat':
                // IVF Flat - can use larger batches for better clustering
                trainingParams = {
                    batchSize: 4096,
                    maxIters: 150,
                    tolerance: 1e-7
                };
                break;
                
            case 'ivf_pq':
                // IVF PQ - needs careful training for quantization
                trainingParams = {
                    batchSize: 3072,
                    maxIters: 200,
                    tolerance: 1e-8
                };
                break;
                
            default:
                console.warn(`Unknown index type: ${indexType}, using default parameters`);
        }
        
        console.log('Training with optimized parameters:', trainingParams);
        
        const result = await index.train(
            trainingParams.batchSize,
            trainingParams.maxIters,
            trainingParams.tolerance
        );
        
        console.log(`Training completed for ${indexType} index:`, result);
        return result;
        
    } catch (error: any) {
        console.error('Optimized training failed:', error.message);
        throw error;
    }
}

// Usage
const optimizedResult = await optimizedTrainingByType(index);
```

### Response Format

The method returns a response object with the following structure:

```typescript
// Standard training completion response
{
    "status": "success",
    "message": "Index 'my-vector-index' trained successfully"
}
```

### Response Fields

| Field | Type | Description |
|-------|------|-------------|
| `status` | `string` | Operation status (typically "success") |
| `message` | `string` | Descriptive message about the training completion |

### Training Performance Tips

- **Index Size**: Larger indexes take longer to train but may benefit from larger batch sizes
- **Memory Usage**: Larger batch sizes use more memory but can improve training quality
- **Convergence**: Lower tolerance values result in more precise training but take longer
- **Index Type**: Different index types (IVF, IVF Flat, IVF PQ) have different optimal parameters
- **Vector Count**: Ensure you have sufficient vectors before training (recommended: at least 100-1000 vectors)

### Best Practices

- **Check Training Status**: Use `isTrained()` to check if training is needed
- **Train After Bulk Upserts**: Train once after adding many vectors rather than after each insert
- **Monitor Performance**: Track training duration and adjust parameters based on requirements
- **Error Handling**: Implement retry logic for training failures
- **Resource Planning**: Training is compute-intensive - plan for appropriate system resources
- **Parameter Tuning**: Experiment with parameters based on your specific use case and performance requirements

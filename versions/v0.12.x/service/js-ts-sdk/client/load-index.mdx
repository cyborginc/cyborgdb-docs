---
title: "Load Index"
mode: "wide"
---

Loads and connects to an existing encrypted index using its name and encryption key.

```typescript
async loadIndex(
    indexName: string,
    indexKey: Uint8Array
): Promise<EncryptedIndex>
```

### Parameters

| Parameter | Type | Description |
|-----------|------|-------------|
| `indexName` | `string` | Name of the existing index to load |
| `indexKey` | `Uint8Array` | The exact 32-byte encryption key used when creating the index |

### Returns

`Promise<EncryptedIndex>`: A Promise that resolves to an `EncryptedIndex` instance ready for vector operations (query, upsert, delete, etc.)

### Exceptions

<AccordionGroup>
    <Accordion title="Error">
        - Throws if the index doesn't exist on the server
        - Throws if the encryption key is incorrect or invalid
        - Throws if the encryption key is not exactly 32 bytes
        - Throws if authentication fails (invalid API key)
    </Accordion>
    <Accordion title="Network/API Errors">
        - Throws if the API request fails due to network issues
        - Throws if the server returns an HTTP error status
        - Throws if the server is unreachable or times out
    </Accordion>
</AccordionGroup>

### Example Usage

#### Loading an Existing Index

```typescript
import { Client } from 'cyborgdb';

const client = new Client('http://localhost:8000', 'your-api-key');

// Use the same key that was used to create the index
const indexKey = new Uint8Array(32); // Your stored 32-byte key
// Or convert from hex: Buffer.from('your-hex-key', 'hex')

try {
    const index = await client.loadIndex('my-existing-index', indexKey);
    console.log('Index loaded successfully');
    
    // Now you can perform operations on the loaded index
    const results = await index.query([0.1, 0.2, 0.3], { topK: 5 });
    console.log('Query results:', results);
} catch (error) {
    console.error('Failed to load index:', error.message);
}
```

#### Loading with Stored Hex Key

```typescript
import { Client } from 'cyborgdb';

const client = new Client('http://localhost:8000', 'your-api-key');

// Convert stored hex key back to Uint8Array
const storedHexKey = 'a1b2c3d4e5f6...'; // Your stored hex key
const indexKey = new Uint8Array(Buffer.from(storedHexKey, 'hex'));

try {
    const index = await client.loadIndex('production-search-index', indexKey);
    
    // Index is ready for operations
    await index.upsert([
        { id: '1', vector: [0.1, 0.2, 0.3], metadata: { type: 'document' } }
    ]);
    
    console.log('Successfully loaded and updated index');
} catch (error) {
    if (error.message.includes('401') || error.message.includes('authentication')) {
        console.error('Invalid encryption key or API key');
    } else if (error.message.includes('404')) {
        console.error('Index not found');
    } else {
        console.error('Load failed:', error.message);
    }
}
```

### Security Notes

- The encryption key must match exactly the key used during index creation
- Invalid keys will result in authentication errors, not data corruption
- Keys should be stored securely and never exposed in client-side code

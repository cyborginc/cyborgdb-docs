---
title: "Getters"
---

## getIndexName

```typescript
async getIndexName(): Promise<string>
```

Retrieves the name of the encrypted index from the CyborgDB service.

### Returns

`Promise<string>`: A Promise that resolves to the unique name identifier of the index.

### Exceptions

- Throws if the API request fails due to network connectivity issues
- Throws if authentication fails (invalid API key or encryption key)
- Throws if the index doesn't exist on the server

### Example Usage

```typescript
try {
    const indexName = await index.getIndexName();
    console.log('Index name:', indexName);
    // Output: "my-vectors"
    
    // Use for verification
    if (indexName === 'expected-index-name') {
        console.log('âœ“ Connected to correct index');
    }
} catch (error) {
    console.error('Failed to get index name:', error.message);
}
```

---

## getIndexType

```typescript
async getIndexType(): Promise<string | undefined>
```

Retrieves the type of the index from the CyborgDB service.

### Returns

`Promise<string | undefined>`: A Promise that resolves to the index type (`'ivf'`, `'ivf_flat'`, or `'ivf_pq'`), or `undefined` if not set.

### Exceptions

- Throws if the API request fails due to network connectivity issues
- Throws if authentication fails (invalid API key or encryption key)
- Throws if the index doesn't exist on the server

### Example Usage

```typescript
try {
    const indexType = await index.getIndexType();
    console.log('Index type:', indexType);
    // Output: "ivf_flat"

    switch (indexType) {
        case 'ivf_pq':
            console.log('Using IVFPQ index for memory efficiency');
            break;
        case 'ivf_flat':
            console.log('Using IVFFlat index for high accuracy');
            break;
        case 'ivf':
            console.log('Using standard IVF index');
            break;
        default:
            console.log('Unknown or undefined index type');
    }
} catch (error) {
    console.error('Failed to get index type:', error.message);
}
```

---

## isTrained

```typescript
async isTrained(): Promise<boolean>
```

Checks whether the index has been trained by querying the CyborgDB service. Training is required for optimal query performance on IVF-based indexes.

### Returns

`Promise<boolean>`: A Promise that resolves to `true` if the index has been trained, `false` otherwise.

### Exceptions

- Throws if the API request fails due to network connectivity issues
- Throws if authentication fails (invalid API key or encryption key)
- Throws if the index doesn't exist on the server

### Example Usage

```typescript
try {
    const trained = await index.isTrained();
    console.log('Index trained:', trained);

    if (!trained) {
        console.log('Index needs training for optimal performance');
        await index.train();
        
        // Verify training completed
        const isNowTrained = await index.isTrained();
        console.log('Training completed:', isNowTrained);
    } else {
        console.log('Index is ready for queries');
    }
} catch (error) {
    console.error('Failed to check training status:', error.message);
}
```

---

## getIndexConfig

```typescript
async getIndexConfig(): Promise<IndexIVFFlat | IndexIVF | IndexIVFPQ>
```

Retrieves the complete index configuration from the CyborgDB service and returns a copy to prevent external modification of the internal state. The return type depends on the index type.

### Returns

- `Promise<IndexIVFFlat>`: For IVF Flat indexes
- `Promise<IndexIVF>`: For standard IVF indexes  
- `Promise<IndexIVFPQ>`: For IVF PQ indexes

### Exceptions

- Throws if the API request fails due to network connectivity issues
- Throws if authentication fails (invalid API key or encryption key)
- Throws if the index doesn't exist on the server

### Example Usage

```typescript
try {
    const config = await index.getIndexConfig();
    console.log('Index configuration:', config);

    // Access common properties
    console.log('Index Type:', config.indexType);
    console.log('Dimension:', config.dimension);
    console.log('Metric:', config.metric);
    console.log('Number of lists:', config.nLists);

    // Type-specific properties
    if (config.indexType === 'ivf_pq') {
        const pqConfig = config as IndexIVFPQ;
        console.log('PQ dimension:', pqConfig.pqDim);
        console.log('PQ bits:', pqConfig.pqBits);
    }
} catch (error) {
    console.error('Failed to get index config:', error.message);
}
```

### Configuration Properties

#### Common Properties (All Index Types)

| Property | Type | Description |
|----------|------|-------------|
| `indexType` | `string` | Index type (`'ivf'`, `'ivf_flat'`, or `'ivf_pq'`) |
| `dimension` | `number` | Vector dimensionality |
| `metric` | `string` | Distance metric (`'cosine'`, `'euclidean'`, etc.) |
| `nLists` | `number` | Number of inverted lists for clustering |

#### IVFPQ-Specific Properties

| Property | Type | Description |
|----------|------|-------------|
| `pqDim` | `number` | Product quantization dimension |
| `pqBits` | `number` | Number of bits for quantization |

### Advanced Usage

```typescript
// Comprehensive index analysis with error handling
async function analyzeIndexCapabilities(index: EncryptedIndex) {
    try {
        console.log('Gathering index information...');
        
        // Fetch all index information concurrently
        const [indexName, indexType, trained, config] = await Promise.all([
            index.getIndexName(),
            index.getIndexType(),
            index.isTrained(),
            index.getIndexConfig()
        ]);
        
        console.log(`\nIndex Analysis: ${indexName}`);
        console.log('='.repeat(40));
        console.log(`Type: ${indexType}`);
        console.log(`Dimensions: ${config.dimension}`);
        console.log(`Metric: ${config.metric}`);
        console.log(`Lists: ${config.nLists}`);
        console.log(`Trained: ${trained ? 'Yes' : 'No'}`);
        
        // Performance characteristics based on type
        console.log('\nCharacteristics:');
        switch (indexType) {
            case 'ivf_flat':
                console.log('- Highest accuracy');
                console.log('- Slower queries');
                console.log('- Higher memory usage');
                break;
            case 'ivf_pq':
                const pqConfig = config as IndexIVFPQ;
                console.log('- Memory efficient');
                console.log('- Compressed vectors');
                console.log(`- PQ dimension: ${pqConfig.pqDim}`);
                console.log(`- Quantization bits: ${pqConfig.pqBits}`);
                const compressionRatio = config.dimension ? (config.dimension / (pqConfig.pqDim || 1)) : 'Unknown';
                console.log(`- Compression ratio: ${compressionRatio}`);
                break;
            case 'ivf':
                console.log('- Balanced performance');
                console.log('- Good accuracy/speed tradeoff');
                break;
            default:
                console.log('- Unknown index type characteristics');
        }
        
        // Actionable recommendations
        console.log('\nRecommendations:');
        const recommendations = [];
        
        if (!trained) {
            recommendations.push('Train the index for optimal performance');
        }
        if (config.nLists && config.nLists < 100) {
            recommendations.push('Consider more lists for larger datasets');
        }
        if (config.dimension && config.dimension > 1000) {
            recommendations.push('Consider using IVFPQ for memory efficiency with high-dimensional vectors');
        }
        
        if (recommendations.length === 0) {
            console.log('- Index appears to be optimally configured');
        } else {
            recommendations.forEach(rec => console.log(`- ${rec}`));
        }
        
        return {
            name: indexName,
            type: indexType,
            trained,
            config,
            recommendations
        };
        
    } catch (error) {
        console.error('Failed to analyze index:', error.message);
        throw error;
    }
}

// Usage
try {
    const analysis = await analyzeIndexCapabilities(index);
    console.log('\nAnalysis completed successfully');
} catch (error) {
    console.error('Index analysis failed:', error.message);
}
```
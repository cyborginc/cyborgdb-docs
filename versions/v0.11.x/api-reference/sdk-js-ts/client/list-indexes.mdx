---
title: "List Indexes"
mode: "wide"
---

Retrieves a list of all available indexes from the CyborgDB microservice.

```typescript
async listIndexes(): Promise<string[]>
```

### Parameters

This method takes no parameters.

### Returns

`Promise<string[]>`: A Promise that resolves to an array of index names currently available on the CyborgDB service.

### Exceptions

<AccordionGroup>
    <Accordion title="Error">
        - Throws if the API request fails due to network connectivity issues.
        - Throws if the server returns an HTTP error status.
        - Throws if authentication fails (invalid API key).
    </Accordion>
    <Accordion title="Service Errors">
        - Throws if the CyborgDB service is unavailable or unreachable.
        - Throws if there are internal server errors on the CyborgDB service.
    </Accordion>
</AccordionGroup>

### Example Usage

#### Basic Index Listing

```typescript
import { Client } from '@cyborgdb/sdk-js-ts';

const client = new Client('https://your-cyborgdb-service.com', 'your-api-key');

try {
    const indexes = await client.listIndexes();
    console.log('Available indexes:', indexes);
    // Output: ['my_vector_index', 'semantic_search', 'document_embeddings']
} catch (error) {
    console.error('Failed to list indexes:', error.message);
}
```

#### Checking if Index Exists

```typescript
import { Client } from '@cyborgdb/sdk-js-ts';

const client = new Client('https://your-cyborgdb-service.com', 'your-api-key');

async function indexExists(indexName: string): Promise<boolean> {
    try {
        const indexes = await client.listIndexes();
        return indexes.includes(indexName);
    } catch (error) {
        console.error('Error checking index existence:', error.message);
        return false;
    }
}

// Usage
const exists = await indexExists('my_index');
if (exists) {
    console.log('Index already exists, loading it...');
    // Load existing index logic here
} else {
    console.log('Index does not exist, creating new one...');
    // Create new index logic here
}
```

#### Listing and Managing Multiple Indexes

```typescript
import { Client } from '@cyborgdb/sdk-js-ts';

const client = new Client('https://your-cyborgdb-service.com', 'your-api-key');

async function manageIndexes() {
    try {
        const indexes = await client.listIndexes();
        
        if (indexes.length === 0) {
            console.log('No indexes found. Create your first index!');
            return;
        }
        
        console.log(`Found ${indexes.length} indexes:`);
        indexes.forEach((indexName, index) => {
            console.log(`${index + 1}. ${indexName}`);
        });
        
        // Filter indexes by naming pattern
        const prodIndexes = indexes.filter(name => name.startsWith('prod_'));
        const devIndexes = indexes.filter(name => name.startsWith('dev_'));
        
        console.log(`Production indexes: ${prodIndexes.length}`);
        console.log(`Development indexes: ${devIndexes.length}`);
        
    } catch (error) {
        console.error('Error managing indexes:', error.message);
    }
}

await manageIndexes();
```

#### Error Handling with Retry Logic

```typescript
import { Client } from '@cyborgdb/sdk-js-ts';

const client = new Client('https://your-cyborgdb-service.com', 'your-api-key');

async function listIndexesWithRetry(maxRetries = 3): Promise<string[]> {
    let lastError: Error;
    
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
        try {
            const indexes = await client.listIndexes();
            console.log(`Successfully retrieved ${indexes.length} indexes on attempt ${attempt}`);
            return indexes;
        } catch (error) {
            lastError = error as Error;
            console.warn(`Attempt ${attempt} failed:`, error.message);
            
            if (attempt < maxRetries) {
                // Wait before retrying (exponential backoff)
                const delay = Math.pow(2, attempt) * 1000;
                console.log(`Retrying in ${delay}ms...`);
                await new Promise(resolve => setTimeout(resolve, delay));
            }
        }
    }
    
    throw new Error(`Failed to list indexes after ${maxRetries} attempts. Last error: ${lastError.message}`);
}

// Usage
try {
    const indexes = await listIndexesWithRetry();
    console.log('Indexes retrieved successfully:', indexes);
} catch (error) {
    console.error('All retry attempts failed:', error.message);
}
```

#### Integration with Index Creation Workflow

```typescript
import { Client, IndexIVFModel } from '@cyborgdb/sdk-js-ts';

const client = new Client('https://your-cyborgdb-service.com', 'your-api-key');

async function ensureIndexExists(indexName: string) {
    try {
        // Check if index already exists
        const existingIndexes = await client.listIndexes();
        
        if (existingIndexes.includes(indexName)) {
            console.log(`Index '${indexName}' already exists`);
            return indexName;
        }
        
        // Index doesn't exist, create it
        console.log(`Creating new index: ${indexName}`);
        
        const indexKey = crypto.getRandomValues(new Uint8Array(32));
        const config: IndexIVFModel = {
            type: 'ivf',
            dimension: 768,
            nLists: 1024,
            metric: 'cosine'
        };
        
        await client.createIndex(indexName, indexKey, config);
        
        // Verify creation by listing again
        const updatedIndexes = await client.listIndexes();
        if (updatedIndexes.includes(indexName)) {
            console.log(`Index '${indexName}' created successfully`);
            return indexName;
        } else {
            throw new Error('Index creation failed - not found in updated list');
        }
        
    } catch (error) {
        console.error(`Error ensuring index exists:`, error.message);
        throw error;
    }
}

// Usage
await ensureIndexExists('my_application_index');
```

### Response Format

The method returns a simple array of strings representing index names:

```typescript
// Example response
[
    "user_embeddings",
    "document_vectors", 
    "product_similarity",
    "semantic_search_v2"
]
```

### Best Practices

- **Cache Results**: If you're calling `listIndexes()` frequently, consider caching the results for a reasonable time period
- **Error Handling**: Always wrap calls in try/catch blocks for robust error handling
- **Naming Conventions**: Use consistent naming patterns for your indexes to make management easier
- **Environment Separation**: Use prefixes like `prod_`, `dev_`, or `test_` to separate indexes by environment

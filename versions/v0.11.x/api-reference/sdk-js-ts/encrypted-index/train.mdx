---
title: "Train"
mode: "wide"
---

Trains the encrypted index to optimize it for efficient similarity search queries. Training is essential for IVF-based indexes to achieve optimal query performance and accuracy.

```typescript
async train(
    batchSize: number = 2048,
    maxIters: number = 100,
    tolerance: number = 1e-6
): Promise<CyborgdbServiceApiSchemasIndexSuccessResponseModel>
```

### Parameters

| Parameter | Type | Default | Description |
|-----------|------|---------|-------------|
| `batchSize` | `number` | `2048` | _(Optional)_ Size of each batch processed during training. Larger values may improve training quality but use more memory |
| `maxIters` | `number` | `100` | _(Optional)_ Maximum number of iterations for the training algorithm. More iterations may improve accuracy but take longer |
| `tolerance` | `number` | `1e-6` | _(Optional)_ Convergence tolerance for training. Smaller values result in more precise training but may take longer |

<Note>Training is a compute-intensive operation that may take several seconds to minutes depending on the index size and configuration.</Note>

### Returns

`Promise<CyborgdbServiceApiSchemasIndexSuccessResponseModel>`: A Promise that resolves to a success response object containing the operation status and training completion message.

### Exceptions

<AccordionGroup>
    <Accordion title="Error">
        - Throws if the API request fails due to network connectivity issues.
        - Throws if authentication fails (invalid API key).
        - Throws if the encryption key is invalid for the specified index.
        - Throws if there are insufficient resources to complete training.
    </Accordion>
    <Accordion title="Training Errors">
        - Throws if the index has no vectors to train on.
        - Throws if the index configuration is incompatible with training.
        - Throws if training parameters are out of valid ranges.
        - Throws if training fails to converge within the specified parameters.
    </Accordion>
</AccordionGroup>

### Example Usage

#### Basic Index Training

```typescript
import { Client, IndexIVFModel } from '@cyborgdb/sdk-js-ts';

const client = new Client('https://your-cyborgdb-service.com', 'your-api-key');

// Create and populate index
const indexKey = crypto.getRandomValues(new Uint8Array(32));
const config: IndexIVFModel = {
    type: 'ivf',
    dimension: 768,
    nLists: 1024,
    metric: 'cosine'
};

const index = await client.createIndex('my-vectors', indexKey, config);

// Add vectors to the index
await index.upsert([
    { id: 'doc1', vector: [0.1, 0.2, 0.3, /* ... 768 dimensions */], metadata: { title: 'Document 1' } },
    { id: 'doc2', vector: [0.4, 0.5, 0.6, /* ... 768 dimensions */], metadata: { title: 'Document 2' } },
    { id: 'doc3', vector: [0.7, 0.8, 0.9, /* ... 768 dimensions */], metadata: { title: 'Document 3' } }
]);

// Train the index with default parameters
try {
    console.log('Starting index training...');
    const startTime = Date.now();
    
    const result = await index.train();
    
    const duration = Date.now() - startTime;
    console.log(`Training completed in ${duration}ms`);
    console.log('Training result:', result.message);
    // Output: "Index 'my-vectors' trained successfully"
    
    // Index is now optimized for queries
    const queryResults = await index.query([0.1, 0.2, 0.3, /* ... */], 5);
    console.log('Query after training:', queryResults);
    
} catch (error) {
    console.error('Training failed:', error.message);
}
```

#### Custom Training Parameters

```typescript
// High-quality training with custom parameters
async function trainHighQuality(index: EncryptedIndex) {
    try {
        const result = await index.train(
            4096,    // batchSize: larger batches for better quality
            200,     // maxIters: more iterations for convergence
            1e-8     // tolerance: stricter convergence criteria
        );
        
        console.log('High-quality training completed:', result.message);
        return result;
        
    } catch (error) {
        console.error('High-quality training failed:', error.message);
        throw error;
    }
}

// Fast training with relaxed parameters
async function trainFast(index: EncryptedIndex) {
    try {
        const result = await index.train(
            1024,    // batchSize: smaller batches for speed
            50,      // maxIters: fewer iterations for speed
            1e-4     // tolerance: relaxed convergence for speed
        );
        
        console.log('Fast training completed:', result.message);
        return result;
        
    } catch (error) {
        console.error('Fast training failed:', error.message);
        throw error;
    }
}

// Usage based on requirements
if (requiresHighAccuracy) {
    await trainHighQuality(index);
} else {
    await trainFast(index);
}
```

#### Training with Progress Monitoring

```typescript
async function trainWithProgress(index: EncryptedIndex, indexName: string) {
    console.log(`Starting training for index: ${indexName}`);
    console.log('This may take a while depending on the index size...');
    
    const startTime = Date.now();
    
    try {
        // Show a simple progress indicator
        const progressInterval = setInterval(() => {
            const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);
            console.log(`Training in progress... ${elapsed}s elapsed`);
        }, 5000); // Update every 5 seconds
        
        const result = await index.train();
        
        clearInterval(progressInterval);
        
        const totalTime = ((Date.now() - startTime) / 1000).toFixed(1);
        console.log(`Training completed successfully in ${totalTime}s`);
        console.log(`Result: ${result.message}`);
        
        return result;
        
    } catch (error) {
        const totalTime = ((Date.now() - startTime) / 1000).toFixed(1);
        console.log(`Training failed after ${totalTime}s`);
        console.error('Error details:', error.message);
        throw error;
    }
}

// Usage
await trainWithProgress(index, 'my-search-index');
```

#### Adaptive Training Strategy

```typescript
class AdaptiveTrainer {
    private index: EncryptedIndex;
    private indexName: string;
    
    constructor(index: EncryptedIndex, indexName: string) {
        this.index = index;
        this.indexName = indexName;
    }
    
    async trainAdaptive(vectorCount: number, indexType: string) {
        let batchSize: number;
        let maxIters: number;
        let tolerance: number;
        
        // Adjust parameters based on index size and type
        if (vectorCount < 1000) {
            // Small index - use default parameters
            batchSize = 1024;
            maxIters = 50;
            tolerance = 1e-4;
            console.log('Using small index training parameters');
        } else if (vectorCount < 10000) {
            // Medium index - balanced parameters
            batchSize = 2048;
            maxIters = 100;
            tolerance = 1e-6;
            console.log('Using medium index training parameters');
        } else {
            // Large index - optimized for large datasets
            batchSize = 4096;
            maxIters = 150;
            tolerance = 1e-7;
            console.log('Using large index training parameters');
        }
        
        // Adjust for index type
        if (indexType === 'ivfpq') {
            // IVFPQ may need more iterations for convergence
            maxIters = Math.floor(maxIters * 1.5);
            console.log('Adjusted parameters for IVFPQ index type');
        }
        
        console.log(`Training ${this.indexName} with ${vectorCount} vectors`);
        console.log(`Parameters: batchSize=${batchSize}, maxIters=${maxIters}, tolerance=${tolerance}`);
        
        try {
            const result = await this.index.train(batchSize, maxIters, tolerance);
            console.log('Adaptive training completed successfully');
            return result;
        } catch (error) {
            console.error('Adaptive training failed:', error.message);
            throw error;
        }
    }
    
    async trainWithRetry(maxRetries: number = 3) {
        let lastError: Error;
        
        for (let attempt = 1; attempt <= maxRetries; attempt++) {
            try {
                console.log(`Training attempt ${attempt}/${maxRetries}`);
                
                // Use progressively more relaxed parameters on retries
                const relaxation = attempt - 1;
                const batchSize = Math.max(1024, 2048 - (relaxation * 512));
                const maxIters = Math.max(25, 100 - (relaxation * 25));
                const tolerance = Math.min(1e-3, 1e-6 * Math.pow(10, relaxation));
                
                const result = await this.index.train(batchSize, maxIters, tolerance);
                console.log(`Training succeeded on attempt ${attempt}`);
                return result;
                
            } catch (error) {
                lastError = error as Error;
                console.warn(`Training attempt ${attempt} failed:`, error.message);
                
                if (attempt < maxRetries) {
                    const delay = Math.pow(2, attempt) * 1000; // Exponential backoff
                    console.log(`Waiting ${delay}ms before retry...`);
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
            }
        }
        
        throw new Error(`Training failed after ${maxRetries} attempts. Last error: ${lastError.message}`);
    }
}

// Usage
const trainer = new AdaptiveTrainer(index, 'my-large-index');

// Adaptive training based on data characteristics
await trainer.trainAdaptive(5000, 'ivf');

// Training with automatic retry
await trainer.trainWithRetry(3);
```

#### Batch Training Workflow

```typescript
async function trainMultipleIndexes(
    client: Client, 
    indexConfigs: Array<{name: string, key: Uint8Array, data: any[]}>
) {
    const results = [];
    
    for (const config of indexConfigs) {
        try {
            console.log(`\nProcessing index: ${config.name}`);
            
            // Create or load index
            console.log('Creating index...');
            const indexConfig = {
                type: 'ivf' as const,
                dimension: 768,
                nLists: 1024,
                metric: 'cosine' as const
            };
            
            const index = await client.createIndex(config.name, config.key, indexConfig);
            
            // Add data
            console.log(`Adding ${config.data.length} vectors...`);
            await index.upsert(config.data);
            
            // Train index
            console.log('Training index...');
            const trainResult = await index.train();
            
            // Verify with a test query
            console.log('Testing trained index...');
            const testQuery = config.data[0]?.vector || new Array(768).fill(0);
            const testResults = await index.query(testQuery, 3);
            
            results.push({
                name: config.name,
                status: 'success',
                message: trainResult.message,
                testResultCount: Array.isArray(testResults.results) ? testResults.results.length : 0
            });
            
            console.log(`${config.name} completed successfully`);
            
        } catch (error) {
            console.error(`${config.name} failed:`, error.message);
            results.push({
                name: config.name,
                status: 'failed',
                error: error.message
            });
        }
    }
    
    // Summary
    console.log('\nTraining Summary:');
    const successful = results.filter(r => r.status === 'success').length;
    const failed = results.filter(r => r.status === 'failed').length;
    
    console.log(`Successful: ${successful}`);
    console.log(`Failed: ${failed}`);
    
    if (failed > 0) {
        console.log('\nFailed indexes:');
        results.filter(r => r.status === 'failed').forEach(r => {
            console.log(`  - ${r.name}: ${r.error}`);
        });
    }
    
    return results;
}

// Usage
const indexConfigs = [
    { name: 'documents', key: crypto.getRandomValues(new Uint8Array(32)), data: documentVectors },
    { name: 'images', key: crypto.getRandomValues(new Uint8Array(32)), data: imageVectors },
    { name: 'products', key: crypto.getRandomValues(new Uint8Array(32)), data: productVectors }
];

const batchResults = await trainMultipleIndexes(client, indexConfigs);
```

#### Training Performance Benchmarking

```typescript
async function benchmarkTraining(index: EncryptedIndex, vectorCount: number) {
    const benchmarks = [
        { name: 'Fast', batchSize: 1024, maxIters: 25, tolerance: 1e-3 },
        { name: 'Balanced', batchSize: 2048, maxIters: 100, tolerance: 1e-6 },
        { name: 'High Quality', batchSize: 4096, maxIters: 200, tolerance: 1e-8 }
    ];
    
    const results = [];
    
    for (const config of benchmarks) {
        try {
            console.log(`\nTesting ${config.name} configuration...`);
            
            const startTime = Date.now();
            const trainResult = await index.train(
                config.batchSize,
                config.maxIters,
                config.tolerance
            );
            const trainingTime = Date.now() - startTime;
            
            // Test query performance
            const queryVector = new Array(768).fill(0).map(() => Math.random());
            const queryStart = Date.now();
            const queryResults = await index.query(queryVector, 10);
            const queryTime = Date.now() - queryStart;
            
            results.push({
                configuration: config.name,
                trainingTime: trainingTime,
                queryTime: queryTime,
                resultCount: Array.isArray(queryResults.results) ? queryResults.results.length : 0,
                success: true
            });
            
            console.log(`${config.name}: Training=${trainingTime}ms, Query=${queryTime}ms`);
            
        } catch (error) {
            console.error(`${config.name} failed:`, error.message);
            results.push({
                configuration: config.name,
                success: false,
                error: error.message
            });
        }
    }
    
    // Analysis
    console.log('\nBenchmark Results:');
    const successful = results.filter(r => r.success);
    
    if (successful.length > 0) {
        console.log('Training Times:');
        successful.forEach(r => {
            console.log(`  ${r.configuration}: ${r.trainingTime}ms`);
        });
        
        console.log('Query Performance:');
        successful.forEach(r => {
            console.log(`  ${r.configuration}: ${r.queryTime}ms`);
        });
        
        // Find optimal configuration
        const optimal = successful.reduce((best, current) => {
            const bestScore = (best.trainingTime + best.queryTime * 10); // Weight query time higher
            const currentScore = (current.trainingTime + current.queryTime * 10);
            return currentScore < bestScore ? current : best;
        });
        
        console.log(`Optimal configuration: ${optimal.configuration}`);
    }
    
    return results;
}

// Usage
const benchmarkResults = await benchmarkTraining(index, 10000);
```

### Response Format

The method returns a success response object with the following structure:

```typescript
// Standard training completion response
{
    "status": "success",
    "message": "Index 'my-vectors' trained successfully"
}
```

#### Response Fields

| Field | Type | Description |
|-------|------|-------------|
| `status` | `string` | Operation status (typically "success") |
| `message` | `string` | Descriptive message about the training completion |

### When to Train

Training is required in the following scenarios:

- **After Index Creation**: New indexes need training before efficient querying
- **After Bulk Data Addition**: When adding large amounts of new data
- **Performance Degradation**: When query performance noticeably decreases
- **Index Modifications**: After significant changes to the vector dataset

### Performance Considerations

#### Parameter Selection

- **Small datasets (< 1,000 vectors)**: Use default parameters or smaller batch sizes
- **Medium datasets (1,000-10,000 vectors)**: Use default parameters
- **Large datasets (> 10,000 vectors)**: Consider larger batch sizes and more iterations

#### Index Type Impact

- **IVF**: Requires training for optimal performance
- **IVFFlat**: Benefits significantly from training
- **IVFPQ**: May require more iterations due to quantization complexity

#### Memory Considerations

- Larger batch sizes use more memory but may improve training quality
- Monitor memory usage during training of very large indexes
- Consider training in off-peak hours for production systems

### Best Practices

- **Train After Data Loading**: Always train after adding significant amounts of data
- **Monitor Training Time**: Set appropriate timeouts for training operations
- **Parameter Tuning**: Adjust parameters based on your accuracy vs speed requirements
- **Progress Monitoring**: Implement progress tracking for long-running training operations
- **Error Handling**: Implement retry logic with progressive parameter relaxation
- **Testing**: Verify query performance after training completion
- **Documentation**: Document optimal training parameters for your specific use case

### Important Notes

- Training is a blocking operation that may take significant time
- The index remains queryable during training but with potentially suboptimal performance
- Training parameters significantly affect both training time and resulting query performance
- Larger datasets generally benefit from larger batch sizes and more iterations
- Training failure doesn't corrupt the index - you can retry with different parameters

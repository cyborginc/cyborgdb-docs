---
title: "Delete"
mode: "wide"
---

Deletes vectors from the encrypted index by their IDs.

```typescript
async delete(ids: string[]): Promise<CyborgdbServiceApiSchemasVectorsSuccessResponseModel>
```

### Parameters

| Parameter | Type | Description |
|-----------|------|-------------|
| `ids` | `string[]` | Array of vector IDs to delete from the index |

### Returns

`Promise<CyborgdbServiceApiSchemasVectorsSuccessResponseModel>`: A Promise that resolves to a success response object containing the operation status and message with the count of deleted vectors.

### Exceptions

<AccordionGroup>
    <Accordion title="Error">
        - Throws if the API request fails due to network connectivity issues.
        - Throws if authentication fails (invalid API key).
        - Throws if the encryption key is invalid for the specified index.
        - Throws if there are internal server errors preventing the deletion.
    </Accordion>
    <Accordion title="Validation Errors">
        - Throws if the `ids` parameter is null, undefined, or empty.
        - Throws if any of the provided IDs are invalid format.
    </Accordion>
</AccordionGroup>

### Example Usage

#### Basic Vector Deletion

```typescript
import { Client, IndexIVFModel } from '@cyborgdb/sdk-js-ts';

const client = new Client('https://your-cyborgdb-service.com', 'your-api-key');

// Create and populate index
const indexKey = crypto.getRandomValues(new Uint8Array(32));
const config: IndexIVFModel = {
    type: 'ivf',
    dimension: 768,
    nLists: 1024,
    metric: 'cosine'
};

const index = await client.createIndex('my-vectors', indexKey, config);

// Add some vectors
await index.upsert([
    { id: 'doc1', vector: [0.1, 0.2, 0.3, ...], metadata: { title: 'Document 1' } },
    { id: 'doc2', vector: [0.4, 0.5, 0.6, ...], metadata: { title: 'Document 2' } },
    { id: 'doc3', vector: [0.7, 0.8, 0.9, ...], metadata: { title: 'Document 3' } }
]);

// Delete specific vectors
try {
    const result = await index.delete(['doc1', 'doc2']);
    console.log('Deletion result:', result);
    // Output: { status: 'success', message: 'Deleted 2 vectors' }
} catch (error) {
    console.error('Failed to delete vectors:', error.message);
}
```

#### Conditional Vector Deletion

```typescript
async function deleteOldVectors(index: EncryptedIndex) {
    try {
        // Query for vectors to identify old ones
        const allResults = await index.query([0, 0, 0, ...], 1000); // Get many results
        
        // Filter vectors based on metadata (example: delete old documents)
        const cutoffDate = new Date('2023-01-01');
        const idsToDelete: string[] = [];
        
        allResults.results?.forEach(result => {
            result.forEach(item => {
                if (item.metadata?.created_date) {
                    const createdDate = new Date(item.metadata.created_date);
                    if (createdDate < cutoffDate) {
                        idsToDelete.push(item.id);
                    }
                }
            });
        });
        
        if (idsToDelete.length > 0) {
            const result = await index.delete(idsToDelete);
            console.log(`Deleted ${idsToDelete.length} old vectors:`, result.message);
        } else {
            console.log('No old vectors found to delete');
        }
        
    } catch (error) {
        console.error('Error deleting old vectors:', error.message);
    }
}

// Usage
await deleteOldVectors(index);
```

#### Batch Deletion with Error Handling

```typescript
async function safeBatchDelete(index: EncryptedIndex, allIds: string[], batchSize: number = 100) {
    const results = [];
    const failedIds = [];
    
    // Process in batches
    for (let i = 0; i < allIds.length; i += batchSize) {
        const batch = allIds.slice(i, i + batchSize);
        
        try {
            console.log(`Deleting batch ${Math.floor(i / batchSize) + 1}: ${batch.length} vectors`);
            const result = await index.delete(batch);
            
            results.push({
                batch: Math.floor(i / batchSize) + 1,
                ids: batch,
                status: 'success',
                message: result.message
            });
            
            // Add small delay between batches to avoid overwhelming the server
            await new Promise(resolve => setTimeout(resolve, 100));
            
        } catch (error) {
            console.error(`Batch ${Math.floor(i / batchSize) + 1} failed:`, error.message);
            failedIds.push(...batch);
            
            results.push({
                batch: Math.floor(i / batchSize) + 1,
                ids: batch,
                status: 'failed',
                error: error.message
            });
        }
    }
    
    return {
        totalProcessed: allIds.length,
        successfulBatches: results.filter(r => r.status === 'success').length,
        failedBatches: results.filter(r => r.status === 'failed').length,
        failedIds: failedIds,
        details: results
    };
}

// Usage
const idsToDelete = ['doc1', 'doc2', 'doc3', 'doc4', 'doc5']; // ... many IDs
const deletionResults = await safeBatchDelete(index, idsToDelete, 50);

console.log('Batch deletion summary:');
console.log(`Total processed: ${deletionResults.totalProcessed}`);
console.log(`Successful batches: ${deletionResults.successfulBatches}`);
console.log(`Failed batches: ${deletionResults.failedBatches}`);

if (deletionResults.failedIds.length > 0) {
    console.log('Failed IDs:', deletionResults.failedIds);
}
```

#### Delete with Verification

```typescript
async function deleteWithVerification(index: EncryptedIndex, idsToDelete: string[]) {
    try {
        // First verify which vectors exist
        const existingVectors = await index.get(idsToDelete, ['metadata']);
        const existingIds = existingVectors.map(v => v.id);
        
        console.log(`Found ${existingIds.length} vectors to delete out of ${idsToDelete.length} requested`);
        
        if (existingIds.length === 0) {
            console.log('No vectors found to delete');
            return { status: 'success', message: 'No vectors to delete' };
        }
        
        // Delete existing vectors
        const deleteResult = await index.delete(existingIds);
        
        // Verify deletion by trying to retrieve them again
        try {
            const verificationResult = await index.get(existingIds, ['metadata']);
            if (verificationResult.length === 0) {
                console.log('✅ Deletion verified - all vectors successfully removed');
            } else {
                console.warn(`⚠️ Verification failed - ${verificationResult.length} vectors still exist`);
            }
        } catch (verifyError) {
            console.log('✅ Deletion verified - vectors no longer accessible');
        }
        
        return deleteResult;
        
    } catch (error) {
        console.error('Error during verified deletion:', error.message);
        throw error;
    }
}

// Usage
try {
    const result = await deleteWithVerification(index, ['doc1', 'doc2', 'nonexistent']);
    console.log('Verified deletion result:', result);
} catch (error) {
    console.error('Deletion failed:', error.message);
}
```

#### Integration with Data Management

```typescript
class VectorDataManager {
    private index: EncryptedIndex;
    private deletionQueue: string[] = [];
    
    constructor(index: EncryptedIndex) {
        this.index = index;
    }
    
    // Queue vectors for deletion
    queueForDeletion(ids: string | string[]) {
        const idsArray = Array.isArray(ids) ? ids : [ids];
        this.deletionQueue.push(...idsArray);
    }
    
    // Process deletion queue
    async processDeletionQueue() {
        if (this.deletionQueue.length === 0) {
            console.log('No vectors queued for deletion');
            return;
        }
        
        try {
            console.log(`Processing ${this.deletionQueue.length} vectors for deletion`);
            const result = await this.index.delete([...this.deletionQueue]);
            
            // Clear the queue after successful deletion
            this.deletionQueue = [];
            
            console.log('Deletion queue processed:', result.message);
            return result;
            
        } catch (error) {
            console.error('Failed to process deletion queue:', error.message);
            throw error;
        }
    }
    
    // Delete and replace vectors atomically
    async replaceVectors(oldIds: string[], newVectors: any[]) {
        try {
            // First add new vectors
            await this.index.upsert(newVectors);
            console.log(`Added ${newVectors.length} new vectors`);
            
            // Then delete old vectors
            const deleteResult = await this.index.delete(oldIds);
            console.log(`Deleted ${oldIds.length} old vectors`);
            
            return {
                added: newVectors.length,
                deleted: oldIds.length,
                deleteResult: deleteResult
            };
            
        } catch (error) {
            console.error('Error during vector replacement:', error.message);
            throw error;
        }
    }
    
    // Cleanup by pattern
    async deleteByPattern(pattern: RegExp) {
        try {
            // This would require getting all vectors first (not shown for brevity)
            // In practice, you'd implement this based on your indexing strategy
            console.log('Pattern-based deletion not implemented in this example');
            
        } catch (error) {
            console.error('Pattern deletion failed:', error.message);
            throw error;
        }
    }
}

// Usage
const dataManager = new VectorDataManager(index);

// Queue vectors for deletion
dataManager.queueForDeletion(['old1', 'old2']);
dataManager.queueForDeletion('old3');

// Process the queue
await dataManager.processDeletionQueue();

// Replace vectors atomically
await dataManager.replaceVectors(
    ['outdated1', 'outdated2'],
    [
        { id: 'new1', vector: [0.1, 0.2, ...], metadata: { version: '2.0' } },
        { id: 'new2', vector: [0.3, 0.4, ...], metadata: { version: '2.0' } }
    ]
);
```

### Response Format

The method returns a success response object with the following structure:

```typescript
// Standard successful deletion response
{
    "status": "success",
    "message": "Deleted 3 vectors"
}
```

#### Response Fields

| Field | Type | Description |
|-------|------|-------------|
| `status` | `string` | Operation status (typically "success") |
| `message` | `string` | Descriptive message including the count of deleted vectors |

### Best Practices

- **Batch Size**: When deleting many vectors, process them in reasonable batches (50-100 vectors) to avoid timeouts
- **Verification**: For critical deletions, verify the operation by attempting to retrieve the deleted vectors
- **Error Handling**: Implement proper error handling for network failures and invalid IDs
- **Queue Management**: Consider using a deletion queue for managing bulk deletion operations
- **Backup**: For important data, consider backing up vectors before deletion if recovery might be needed
- **Atomic Operations**: When replacing vectors, add new ones first, then delete old ones to maintain data availability

### Performance Considerations

- **Index Type**: Deletion performance may vary based on the index type (IVF, IVFFlat, IVFPQ)
- **Batch Processing**: Batch deletions are more efficient than individual deletions
- **Training**: After large deletions, consider retraining the index for optimal query performance
- **Memory**: Large deletion operations may temporarily increase memory usage during processing

### Important Notes

- Deleted vectors cannot be recovered unless backed up separately
- Vector IDs that don't exist in the index are silently ignored (no error thrown)
- The operation is atomic - either all specified vectors are deleted or none are
- Deletion does not automatically retrain the index - call `train()` if needed for optimal performance

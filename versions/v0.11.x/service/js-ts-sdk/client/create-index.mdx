---
title: "Create Index"
mode: "wide"
---

Creates and returns a new encrypted index based on the provided configuration.

Creates and returns a new encrypted index based on the provided configuration.

```typescript
async createIndex(
    indexName: string, 
    indexKey: Uint8Array, 
    indexConfig: IndexIVFPQModel | IndexIVFFlatModel | IndexIVFModel,
    embeddingModel?: string
): Promise<EncryptedIndex>
```

### Parameters

| Parameter | Type | Description |
|---------------|--------------------|----------------------------------------------------------------------------------------|
| `indexName` | `string` | Name of the index to create. Must be unique within the CyborgDB service. |
| `indexKey` | `Uint8Array` | 32-byte encryption key for the index, used to secure the index data. |
| `indexConfig` | [`IndexIVFPQModel`](../types#indexivfpqmodel) \| [`IndexIVFFlatModel`](../types#indexivfflatmodel) \| [`IndexIVFModel`](../types#indexivfmodel) | Configuration object specifying the index type (`ivf`, `ivfpq`, or `ivfflat`) and relevant parameters such as `dimension`, `nLists`, `pqDim`, and `pqBits`. |
| `embeddingModel` | `string` | _(Optional)_ Name of the embedding model used to auto-generate embeddings on the server. Defaults to `undefined`, no auto-generation. |

<Note>For more info on auto-generating embeddings, refer to [Auto-Generate Embeddings](../../guides/data-operations/add-items#automatic-embedding-generation).</Note>

### Returns

`Promise<EncryptedIndex>`: A Promise that resolves to an instance of the newly created encrypted index.

### Exceptions

<AccordionGroup>
    <Accordion title="Error">
        - Throws if the index name already exists on the server.
        - Throws if the index configuration is invalid or missing required parameters.
        - Throws if the encryption key is not exactly 32 bytes.
        - Throws if the embedding model is not supported by the server.
    </Accordion>
    <Accordion title="Network/API Errors">
        - Throws if the API request fails due to network issues.
        - Throws if the server returns an HTTP error status.
        - Throws if authentication fails (invalid API key).
    </Accordion>
</AccordionGroup>

### Example Usage

#### Basic IVF Index Creation

```typescript
import { Client, IndexIVFModel } from '@cyborgdb/sdk-js-ts';

const client = new Client('https://your-cyborgdb-service.com', 'your-api-key');

const indexName = "my_vector_index";
const indexKey = crypto.getRandomValues(new Uint8Array(32)); // Generate secure 32-byte key

const indexConfig: IndexIVFModel = {
    type: 'ivf',
    dimension: 768,
    nLists: 1024,
    metric: 'cosine'
};

try {
    const index = await client.createIndex(
        indexName, 
        indexKey, 
        indexConfig
    );
    console.log('Index created successfully:', index);
} catch (error) {
    console.error('Failed to create index:', error.message);
}
```

#### IVFPQ Index with Embedding Model

```typescript
import { Client, IndexIVFPQModel } from '@cyborgdb/sdk-js-ts';

const client = new Client('https://your-cyborgdb-service.com', 'your-api-key');

const indexName = "semantic_search_index";
const indexKey = crypto.getRandomValues(new Uint8Array(32));

const indexConfig: IndexIVFPQModel = {
    type: 'ivfpq',
    dimension: 1536,
    nLists: 2048,
    metric: 'cosine',
    pqDim: 64,
    pqBits: 8
};

try {
    const index = await client.createIndex(
        indexName,
        indexKey,
        indexConfig,
        'text-embedding-3-large'  // OpenAI embedding model
    );
    
    console.log('IVFPQ index with embeddings created successfully');
} catch (error) {
    console.error('Index creation failed:', error.message);
}
```

#### IVFFlat Index for High Precision

```typescript
import { Client, IndexIVFFlatModel } from '@cyborgdb/sdk-js-ts';

const client = new Client('https://your-cyborgdb-service.com', 'your-api-key');

const indexName = "high_precision_index";
const indexKey = crypto.getRandomValues(new Uint8Array(32));

const indexConfig: IndexIVFFlatModel = {
    type: 'ivfflat',
    dimension: 512,
    nLists: 100,
    metric: 'euclidean'
};

try {
    const index = await client.createIndex(
        indexName,
        indexKey,
        indexConfig,
        'sentence-transformers/all-MiniLM-L6-v2'
    );
    
    // Index is ready for operations
    await index.upsert([
        { id: '1', vector: [0.1, 0.2, ...], metadata: { title: 'Document 1' } }
    ]);
} catch (error) {
    console.error('Error:', error.message);
}
```

### Key Generation Best Practices

Always generate cryptographically secure keys:

```typescript
// Good: Using crypto.getRandomValues()
const indexKey = crypto.getRandomValues(new Uint8Array(32));

// Good: Node.js crypto module
import { randomBytes } from 'crypto';
const indexKey = new Uint8Array(randomBytes(32));

// Bad: Predictable or weak keys
const badKey = new Uint8Array(32).fill(1); // Don't do this!
```

### Index Configuration Guidelines

Choose the right index type for your use case:

- **IVF**: Best for general-purpose vector search with good balance of speed and accuracy
- **IVFFlat**: Highest accuracy but slower search, good for smaller datasets
- **IVFPQ**: Most memory-efficient, good for large datasets where some accuracy trade-off is acceptable
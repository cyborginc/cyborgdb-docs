---
title: "Query"
mode: "wide"
---

Searches for nearest neighbors in the encrypted index using vector similarity search. Supports both single vector queries and batch queries with multiple vectors.

```typescript
async query(
    ...args: [number[] | number[][], number?, number?, boolean?, object?, string[]?] | [QueryRequest]
): Promise<QueryResponse>
```

### Method Overloads

The `query` method supports two calling patterns:

#### Pattern 1: Individual Parameters

```typescript
async query(
    queryVector: number[] | number[][],
    topK?: number = 100,
    nProbes?: number = 1,
    greedy?: boolean = false,
    filters?: object = {},
    include?: string[] = ["distance", "metadata"]
): Promise<QueryResponse>
```

#### Pattern 2: Request Object

```typescript
async query(request: QueryRequest): Promise<QueryResponse>
```

### Parameters

#### Individual Parameters Pattern

| Parameter | Type | Default | Description |
|-----------|------|---------|-------------|
| `queryVector` | `number[]` \| `number[][]` | - | Single vector (1D array) or multiple vectors (2D array) to search for |
| `topK` | `number` | `100` | _(Optional)_ Number of nearest neighbors to return for each query |
| `nProbes` | `number` | `1` | _(Optional)_ Number of lists to probe during the query (affects accuracy vs speed tradeoff) |
| `greedy` | `boolean` | `false` | _(Optional)_ Whether to use greedy search algorithm |
| `filters` | `object` | `{}` | _(Optional)_ Metadata filters to apply to the search |
| `include` | `string[]` | `["distance", "metadata"]` | _(Optional)_ Fields to include in results: `"distance"`, `"metadata"`, `"vector"`, `"contents"` |

#### Request Object Pattern

| Parameter | Type | Description |
|-----------|------|-------------|
| `request` | [`QueryRequest`](../types#queryrequest) | Complete query request object with all parameters |

### Returns

`Promise<QueryResponse>`: A Promise that resolves to search results. The response format depends on whether a single vector or multiple vectors were queried:

- **Single vector query**: `results` is a flat array of `QueryResultItem[]`
- **Batch query**: `results` is a nested array of `QueryResultItem[][]` (one array per input vector)

### Exceptions

<AccordionGroup>
    <Accordion title="Error">
        - Throws if the API request fails due to network connectivity issues.
        - Throws if authentication fails (invalid API key).
        - Throws if the encryption key is invalid for the specified index.
        - Throws if there are internal server errors during the search.
    </Accordion>
    <Accordion title="Validation Errors">
        - Throws if no query vector is provided.
        - Throws if vector dimensions don't match the index configuration.
        - Throws if parameter values are out of valid ranges.
        - Throws if the `include` parameter contains invalid field names.
    </Accordion>
</AccordionGroup>

### Example Usage

#### Basic Single Vector Query

```typescript
import { Client, IndexIVFModel } from '@cyborgdb/sdk-js-ts';

const client = new Client('https://your-cyborgdb-service.com', 'your-api-key');

// Create and populate index
const indexKey = crypto.getRandomValues(new Uint8Array(32));
const config: IndexIVFModel = {
    type: 'ivf',
    dimension: 768,
    nLists: 1024,
    metric: 'cosine'
};

const index = await client.createIndex('my-vectors', indexKey, config);

// Add some vectors
await index.upsert([
    { 
        id: 'doc1', 
        vector: [0.1, 0.2, 0.3, /* ... 768 dimensions */], 
        metadata: { title: 'Document 1', category: 'research' }
    },
    { 
        id: 'doc2', 
        vector: [0.4, 0.5, 0.6, /* ... 768 dimensions */], 
        metadata: { title: 'Document 2', category: 'tutorial' }
    }
]);

// Train the index for optimal performance
await index.train();

// Search for similar vectors
const queryVector = [0.15, 0.25, 0.35, /* ... 768 dimensions */];

try {
    const results = await index.query(queryVector, 5);
    
    // Single vector query returns flat array
    const items = results.results as QueryResultItem[];
    
    items.forEach((item, i) => {
        console.log(`Result ${i + 1}:`);
        console.log(`  ID: ${item.id}`);
        console.log(`  Distance: ${item.distance}`);
        console.log(`  Metadata: ${JSON.stringify(item.metadata)}`);
    });
    
} catch (error) {
    console.error('Query failed:', error.message);
}
```

#### Advanced Single Query with Options

```typescript
const queryVector = [0.1, 0.2, 0.3, /* ... */];

const results = await index.query(
    queryVector,
    10,        // topK: return top 10 results
    5,         // nProbes: probe 5 lists for better accuracy
    true,      // greedy: use greedy search
    { category: 'research' },  // filters: only research documents
    ['distance', 'metadata', 'contents']  // include: return distance, metadata, and contents
);

const items = results.results as QueryResultItem[];
items.forEach(item => {
    console.log(`${item.id}: distance=${item.distance}, category=${item.metadata?.category}`);
    console.log(`Contents: ${item.contents}`);
});
```

#### Batch Vector Query

```typescript
// Query multiple vectors at once
const queryVectors = [
    [0.1, 0.2, 0.3, /* ... */],  // First query vector
    [0.4, 0.5, 0.6, /* ... */],  // Second query vector
    [0.7, 0.8, 0.9, /* ... */]   // Third query vector
];

const batchResults = await index.query(queryVectors, 3);

// Batch query returns nested arrays
const allResults = batchResults.results as QueryResultItem[][];

allResults.forEach((queryResults, queryIndex) => {
    console.log(`Results for query ${queryIndex + 1}:`);
    queryResults.forEach((item, resultIndex) => {
        console.log(`  ${resultIndex + 1}. ${item.id} (distance: ${item.distance})`);
    });
    console.log('---');
});
```

#### Using Request Object Pattern

```typescript
import { QueryRequest } from '@cyborgdb/sdk-js-ts';

// Single vector query with request object
const singleQueryRequest: QueryRequest = {
    indexName: index.getIndexName(),
    indexKey: 'will-be-set-automatically',
    queryVector: [0.1, 0.2, 0.3, /* ... */],
    topK: 5,
    nProbes: 3,
    greedy: false,
    filters: { status: 'published' },
    include: ['distance', 'metadata', 'vector']
};

const singleResults = await index.query(singleQueryRequest);

// Batch query with request object
const batchQueryRequest: QueryRequest = {
    indexName: index.getIndexName(),
    indexKey: 'will-be-set-automatically',
    queryVectors: [
        [0.1, 0.2, 0.3, /* ... */],
        [0.4, 0.5, 0.6, /* ... */]
    ],
    topK: 10,
    nProbes: 5,
    filters: {},
    include: ['distance', 'metadata']
};

const batchResults = await index.query(batchQueryRequest);
```

#### Metadata Filtering

```typescript
// Filter by single field
const categoryResults = await index.query(
    queryVector, 
    10, 
    1, 
    false, 
    { category: 'research' }
);

// Filter by multiple fields
const complexResults = await index.query(
    queryVector, 
    10, 
    1, 
    false, 
    { 
        category: 'research', 
        published: true,
        year: 2024 
    }
);

// Range filter (if supported by your metadata structure)
const dateResults = await index.query(
    queryVector, 
    10, 
    1, 
    false, 
    { 
        created_date: { 
            $gte: '2024-01-01',
            $lte: '2024-12-31'
        } 
    }
);
```

#### Performance-Optimized Search

```typescript
async function performanceSearch(
    index: EncryptedIndex, 
    queryVector: number[], 
    accuracyLevel: 'fast' | 'balanced' | 'accurate' = 'balanced'
) {
    let nProbes: number;
    let greedy: boolean;
    
    switch (accuracyLevel) {
        case 'fast':
            nProbes = 1;
            greedy = true;
            break;
        case 'balanced':
            nProbes = 5;
            greedy = false;
            break;
        case 'accurate':
            nProbes = 20;
            greedy = false;
            break;
    }
    
    const startTime = Date.now();
    
    const results = await index.query(
        queryVector,
        10,           // topK
        nProbes,      // Based on accuracy level
        greedy,       // Based on accuracy level
        {},           // No filters
        ['distance', 'metadata']  // Minimal fields for speed
    );
    
    const duration = Date.now() - startTime;
    
    console.log(`Search completed in ${duration}ms with ${accuracyLevel} accuracy`);
    console.log(`Found ${(results.results as QueryResultItem[]).length} results`);
    
    return results;
}

// Usage
const fastResults = await performanceSearch(index, queryVector, 'fast');
const accurateResults = await performanceSearch(index, queryVector, 'accurate');
```

#### Similarity Search with Reranking

```typescript
async function searchWithReranking(
    index: EncryptedIndex, 
    queryVector: number[], 
    initialK: number = 50, 
    finalK: number = 10
) {
    try {
        // First pass: Get more results with fast search
        const initialResults = await index.query(
            queryVector,
            initialK,
            1,      // Fast search with few probes
            true,   // Greedy for speed
            {},
            ['distance', 'metadata', 'vector']  // Include vectors for reranking
        );
        
        const items = initialResults.results as QueryResultItem[];
        
        // Second pass: Rerank using custom logic
        const reranked = items
            .map(item => ({
                ...item,
                // Custom score combining distance and metadata relevance
                customScore: calculateCustomScore(item, queryVector)
            }))
            .sort((a, b) => a.customScore - b.customScore)  // Lower is better
            .slice(0, finalK);
        
        console.log(`Reranked from ${items.length} to ${reranked.length} results`);
        return reranked;
        
    } catch (error) {
        console.error('Search with reranking failed:', error.message);
        throw error;
    }
}

function calculateCustomScore(item: QueryResultItem, queryVector: number[]): number {
    let score = item.distance || 1.0;
    
    // Boost score based on metadata relevance
    if (item.metadata?.featured) {
        score *= 0.8;  // 20% boost for featured items
    }
    
    if (item.metadata?.popularity) {
        score *= (1 - item.metadata.popularity * 0.1);  // Up to 10% boost based on popularity
    }
    
    return score;
}

// Usage
const rerankedResults = await searchWithReranking(index, queryVector, 100, 10);
```

#### Parallel Batch Processing

```typescript
async function parallelBatchQuery(
    index: EncryptedIndex, 
    queryVectors: number[][], 
    batchSize: number = 10
) {
    const results = [];
    const batches = [];
    
    // Split into smaller batches
    for (let i = 0; i < queryVectors.length; i += batchSize) {
        batches.push(queryVectors.slice(i, i + batchSize));
    }
    
    console.log(`Processing ${queryVectors.length} queries in ${batches.length} batches`);
    
    // Process batches in parallel
    const batchPromises = batches.map(async (batch, batchIndex) => {
        try {
            console.log(`Processing batch ${batchIndex + 1}/${batches.length}`);
            const batchResults = await index.query(batch, 5);
            return {
                batchIndex,
                success: true,
                results: batchResults.results as QueryResultItem[][]
            };
        } catch (error) {
            console.error(`Batch ${batchIndex + 1} failed:`, error.message);
            return {
                batchIndex,
                success: false,
                error: error.message
            };
        }
    });
    
    const batchResults = await Promise.allSettled(batchPromises);
    
    // Combine successful results
    const successfulBatches = batchResults
        .filter(result => result.status === 'fulfilled' && result.value.success)
        .map(result => (result as PromiseFulfilledResult<any>).value);
    
    const combinedResults: QueryResultItem[][] = [];
    successfulBatches.forEach(batch => {
        combinedResults.push(...batch.results);
    });
    
    console.log(`Completed ${successfulBatches.length}/${batches.length} batches successfully`);
    console.log(`Total results: ${combinedResults.length}`);
    
    return combinedResults;
}

// Usage
const manyQueries = [
    [0.1, 0.2, /* ... */],
    [0.2, 0.3, /* ... */],
    // ... many more query vectors
];

const parallelResults = await parallelBatchQuery(index, manyQueries, 5);
```

### Response Format

The `QueryResponse` object contains a `results` field with different structures based on query type:

#### Single Vector Query Response

```typescript
{
    "results": [
        {
            "id": "doc1",
            "distance": 0.15,
            "metadata": {
                "title": "Document 1",
                "category": "research"
            }
        },
        {
            "id": "doc2", 
            "distance": 0.23,
            "metadata": {
                "title": "Document 2",
                "category": "tutorial"
            }
        }
    ]
}
```

#### Batch Query Response

```typescript
{
    "results": [
        [
            // Results for first query vector
            { "id": "doc1", "distance": 0.15, "metadata": {...} },
            { "id": "doc3", "distance": 0.21, "metadata": {...} }
        ],
        [
            // Results for second query vector  
            { "id": "doc2", "distance": 0.18, "metadata": {...} },
            { "id": "doc4", "distance": 0.25, "metadata": {...} }
        ]
    ]
}
```

#### QueryResultItem Fields

| Field | Type | Description |
|-------|------|-------------|
| `id` | `string` | Unique identifier of the matching vector |
| `distance` | `number` | Similarity distance (lower values indicate higher similarity) |
| `metadata` | `any` | Associated metadata (included if `"metadata"` in include array) |
| `vector` | `number[]` | The vector data (included if `"vector"` in include array) |
| `contents` | `string` | The content data (included if `"contents"` in include array) |

### Performance Tuning

#### nProbes Parameter

- **Low values (1-5)**: Faster queries, lower accuracy
- **Medium values (10-20)**: Balanced performance and accuracy
- **High values (50+)**: Higher accuracy, slower queries

#### Greedy Search

- **Enabled**: Faster queries with slightly lower accuracy
- **Disabled**: More thorough search with better accuracy

#### Include Fields

- **Minimal**: Only include necessary fields to reduce data transfer
- **Complete**: Include all fields when you need full vector data

### Best Practices

- **Index Training**: Always train your index before querying for optimal performance
- **Batch Queries**: Use batch queries for multiple similar operations to reduce API calls
- **Field Selection**: Only include necessary fields in results to improve performance
- **Filter Optimization**: Use metadata filters to reduce search space and improve accuracy
- **Parameter Tuning**: Adjust `nProbes` based on your accuracy vs speed requirements
- **Error Handling**: Implement retry logic for transient network failures
- **Caching**: Cache frequent queries locally when appropriate

### Important Notes

- Queries require the index to be trained for optimal performance
- Distance values depend on the metric used (cosine, euclidean, etc.)
- Batch queries are more efficient than multiple single queries
- All query vectors and results are automatically encrypted/decrypted
- The order of results is by similarity score (most similar first)
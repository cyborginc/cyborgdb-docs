---
title: "Get"
mode: "wide"
---

Retrieves vectors from the encrypted index by their IDs, with options to specify which fields to include in the results.

```typescript
async get(
    ids: string[],
    include: string[] = ["vector", "contents", "metadata"]
): Promise<Array<{ id: string; vector?: number[]; contents?: Buffer | string; metadata?: any }>>
```

### Parameters

| Parameter | Type | Default | Description |
|-----------|------|---------|-------------|
| `ids` | `string[]` | - | Array of vector IDs to retrieve from the index |
| `include` | `string[]` | `["vector", "contents", "metadata"]` | _(Optional)_ Fields to include in the response. Valid options: `"vector"`, `"contents"`, `"metadata"` |

### Returns

`Promise<Array<GetResultItem>>`: A Promise that resolves to an array of retrieved vector items, each containing the requested fields based on the `include` parameter.

### Exceptions

<AccordionGroup>
    <Accordion title="Error">
        - Throws if the API request fails due to network connectivity issues.
        - Throws if authentication fails (invalid API key).
        - Throws if the encryption key is invalid for the specified index.
        - Throws if there are internal server errors preventing the retrieval.
    </Accordion>
    <Accordion title="Validation Errors">
        - Throws if the `ids` parameter is null, undefined, or empty.
        - Throws if the `include` parameter contains invalid field names.
    </Accordion>
</AccordionGroup>

### Example Usage

```typescript
import { Client, IndexIVFModel } from '@cyborgdb/sdk-js-ts';

const client = new Client('https://your-cyborgdb-service.com', 'your-api-key');

// Create and populate index
const indexKey = crypto.getRandomValues(new Uint8Array(32));
const config: IndexIVFModel = {
    type: 'ivf',
    dimension: 768,
    nLists: 1024,
    metric: 'cosine'
};

const index = await client.createIndex('my-vectors', indexKey, config);

// Add some vectors first
await index.upsert([
    { 
        id: 'doc1', 
        vector: [0.1, 0.2, 0.3, /* ... 768 dimensions */], 
        contents: 'This is the first document content',
        metadata: { title: 'Document 1', category: 'research', date: '2024-01-15' }
    },
    { 
        id: 'doc2', 
        vector: [0.4, 0.5, 0.6, /* ... 768 dimensions */], 
        contents: 'This is the second document content',
        metadata: { title: 'Document 2', category: 'tutorial', date: '2024-01-16' }
    }
]);

// Retrieve vectors with all fields
try {
    const vectors = await index.get(['doc1', 'doc2']);
    
    vectors.forEach(item => {
        console.log(`ID: ${item.id}`);
        console.log(`Vector dimensions: ${item.vector?.length}`);
        console.log(`Contents: ${item.contents}`);
        console.log(`Metadata: ${JSON.stringify(item.metadata)}`);
        console.log('---');
    });
    
} catch (error) {
    console.error('Failed to retrieve vectors:', error.message);
}
```

### Response Format

The method returns an array of objects with the following structure:

```typescript
// Example response with all fields
[
    {
        "id": "doc1",
        "vector": [0.1, 0.2, 0.3, /* ... */],
        "contents": "Document content as string or Buffer",
        "metadata": {
            "title": "Document 1",
            "category": "research",
            "date": "2024-01-15"
        }
    },
    {
        "id": "doc2",
        "vector": [0.4, 0.5, 0.6, /* ... */],
        "contents": "Another document content",
        "metadata": {
            "title": "Document 2", 
            "category": "tutorial",
            "date": "2024-01-16"
        }
    }
]
```

#### Response Item Fields

| Field | Type | Description |
|-------|------|-------------|
| `id` | `string` | Unique identifier of the vector (always included) |
| `vector` | `number[]` | The vector data (included if `"vector"` in include array) |
| `contents` | `Buffer` \| `string` | The content data, automatically decoded from base64 if needed (included if `"contents"` in include array) |
| `metadata` | `any` | Associated metadata object (included if `"metadata"` in include array) |

### Field Selection Benefits

Choosing specific fields can significantly improve performance:

- **Metadata only**: Fast existence checks and property inspection
- **Vectors only**: Efficient for similarity calculations and mathematical operations  
- **Contents only**: Quick content retrieval without vector overhead
- **Custom combinations**: Optimize data transfer for specific use cases

### Best Practices

- **Field Selection**: Only request the fields you need to minimize data transfer and processing time
- **Batch Size**: When retrieving many vectors, process them in reasonable batches (25-50 vectors)
- **Error Handling**: Implement proper error handling for network failures and missing vectors
- **Content Processing**: Handle both string and Buffer content types appropriately
- **Caching**: Consider caching frequently accessed vectors locally
- **Existence Checks**: Use metadata-only retrieval for efficient existence verification

### Performance Considerations

- **Network Transfer**: Limiting fields reduces bandwidth usage and improves response times
- **Memory Usage**: Large vectors and content can consume significant memory - process in batches
- **Index Type**: Retrieval performance may vary based on the index configuration
- **Concurrent Requests**: Multiple simultaneous get operations are supported and encouraged

### Important Notes

- Non-existent vector IDs are silently ignored (no error thrown)
- The order of results may not match the order of input IDs
- Content is automatically decoded from base64 storage format when retrieved
- All data is decrypted automatically using the index's encryption key
- Fields not included in the `include` parameter will be `undefined` in the response
